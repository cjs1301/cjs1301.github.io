---
emoji: 👩🏻‍💻
title: "[데이터베이스] JScode 스터디 1주차 (2)"
categories: 데이터베이스
date: '2024-03-07'
---

## 릴레이션 스키마와 릴레이션 인스턴스

### 릴레이션 스키마

릴레이션 스키마는 테이블의 구조를 정의하는 것입니다. 마치 건물의 청사진처럼, 릴레이션 스키마는 테이블이 어떤 형태를 갖고 있는지, 어떤 종류의 데이터를 저장할 수 있는지 설명합니다. 릴레이션 스키마에는 테이블의 이름과 함께 테이블의 각 열(속성)에 대한 정보(이름, 데이터 타입 등)가 포함됩니다.

**예시**: "학생"이라는 테이블의 릴레이션 스키마가 있다고 가정해 봅시다. 이 스키마는 학생의 학번, 이름, 전공 등의 정보를 저장하기 위한 구조를 정의합니다. 따라서 "학생" 테이블의 릴레이션 스키마는 다음과 같이 표현될 수 있습니다: `학생(학번, 이름, 전공)`

### 릴레이션 인스턴스

릴레이션 인스턴스는 릴레이션 스키마에 따라 실제로 저장된 데이터의 집합입니다. 즉, 특정 시점에서 데이터베이스 테이블에 저장된 데이터의 상태를 나타냅니다. 릴레이션 인스턴스는 시간이 지나면서 데이터의 추가, 삭제, 수정에 따라 변경될 수 있습니다.

**예시**: "학생" 테이블의 릴레이션 인스턴스는 실제 학생 데이터를 포함하고 있습니다. 만약 세 명의 학생 정보가 테이블에 저장되어 있다면, 이 테이블의 릴레이션 인스턴스는 세 개의 행(레코드)으로 구성됩니다. 예를 들어:

-   학번: 123, 이름: 홍길동, 전공: 컴퓨터공학
-   학번: 456, 이름: 이순신, 전공: 기계공학
-   학번: 789, 이름: 강감찬, 전공: 전자공학

### 요약

-   **릴레이션 스키마**는 테이블의 구조를 정의합니다(테이블이 어떤 정보를 담을 수 있는지).
-   **릴레이션 인스턴스**는 특정 시점에서 실제로 테이블에 저장된 데이터의 집합입니다(테이블에 실제로 어떤 데이터가 들어있는지).

릴레이션 스키마는 건물의 설계도와 같고, 릴레이션 인스턴스는 그 설계도에 따라 지어진 실제 건물과 그 건물의 현재 상태를 나타내는 것으로 이해할 수 있습니다.

## 릴레이션의 차수와 카니덜리티

### 차수(Degree)

-   **정의**: 릴레이션(테이블)의 차수는 그 테이블이 가지고 있는 속성(열, 컬럼)의 수를 의미합니다.
-   **예시**: 예를 들어, "학생" 테이블에 '학번', '이름', '전공' 이렇게 3개의 컬럼이 있다면, 이 테이블의 차수는 3입니다. 마치 사람이 팔, 다리, 머리 등의 부위를 가지고 있는 것처럼, 테이블이 가지고 있는 "부위"의 수라고 할 수 있습니다.

### 카디널리티(Cardinality)

-   **정의**: 릴레이션의 카디널리티는 그 테이블에 있는 튜플(행, 레코드)의 수를 의미합니다. 데이터베이스에서는 릴레이션 간의 관계에서도 카디널리티를 사용하여 릴레이션 사이의 관계를 설명하기도 합니다(예: 1대1, 1대다, 다대다 관계).
-   **예시**: "학생" 테이블에 100명의 학생 정보가 저장되어 있다면, 이 테이블의 카디널리티는 100입니다. 학교에 다니는 학생의 수를 세는 것과 비슷하게, 테이블에 들어 있는 데이터의 "수"를 세는 것이라고 생각할 수 있습니다.

### 차이점

-   **차수**는 테이블의 **구조적 특성**을 나타내는 것으로, 몇 개의 컬럼(또는 속성)으로 이루어져 있는지를 말합니다.
-   **카디널리티**는 테이블의 **데이터 양**을 나타내는 것으로, 테이블에 실제로 몇 개의 레코드(또는 행)가 있는지를 말합니다.

이 두 개념은 데이터베이스 설계 및 최적화에 있어서 중요한 기준이 됩니다. 차수가 높은 테이블은 더 많은 종류의 정보를 저장할 수 있지만, 관리가 복잡해질 수 있습니다. 카디널리티는 테이블에 저장된 데이터의 양을 나타내므로, 데이터베이스의 성능과 직접적인 관련이 있습니다.

## 키(Key)에 대하여 (슈퍼키, 후보키, 기본키, 대리키, 외래키)

### 슈퍼키(Super Key)

-   **정의**: 테이블 내의 각 레코드를 `유일하게 식별`할 수 있는 하나 이상의 속성(열)의 집합입니다. 슈퍼키는 불필요한 추가 정보를 포함할 수 있습니다. 예를 들어, '학생' 테이블에서 학번과 조합할 수 있는 모든 속성들(학번+이름, 학번+주소 등)이 슈퍼키가 될 수 있습니다.

### 후보키(Candidate Key)

-   **정의**: 레코드를 유일하게 식별할 수 있으면서, 최소한의 속성으로 구성된 슈퍼키입니다. 다시 말해, `불필요한 속성 없이 레코드를 유일하게 식별할 수 있는 키`를 말합니다. 후보키는 여러 개일 수 있습니다.

### 기본키(Primary Key)

-   **정의**: 후보키 중에서 선택된 메인 키로, 각 레코드를 유일하게 식별하는 데 사용됩니다. 기본키는 중복되거나 `NULL` 값을 가질 수 없습니다. 예를 들어, '학생' 테이블에서 학번이 기본키로 선택될 수 있습니다.

### 대리키(Surrogate Key)

-   **정의**: 비즈니스 의미가 없고 데이터베이스 내에서만 사용되는 인위적으로 생성된 키입니다. 주로 기본키로 사용되며, 연속된 번호나 UUID 같은 형식을 가질 수 있습니다. 대리키는 자연키(자연스럽게 데이터에서 파생된 키, 예: 학번) 대신 사용될 수 있습니다.

### 외래키(Foreign Key)

-   **정의**: 한 테이블의 키가 다른 테이블의 기본키(또는 후보키)와 연결되어 있는 속성을 말합니다. 외래키는 두 테이블 간의 관계를 정의하는 데 사용되며, 참조 무결성을 유지하는 데 도움을 줍니다. 예를 들어, '수강신청' 테이블에서 학번이 '학생' 테이블의 학번을 참조하는 외래키일 수 있습니다.

## 무결성 제약조건

### 1. 개체 무결성(Entity Integrity)

-   **정의**: 모든 테이블은 기본키를 가져야 하고, 이 기본키는 유일한 값을 가져야 합니다. 기본키를 통해 각 레코드(행)를 명확하게 식별할 수 있어야 하며, 기본키 값으로 NULL을 허용하지 않습니다. 예를 들어, 학생 테이블에서 학번이 기본키라면, 모든 학번은 고유해야 하고 빈 값이어서는 안 됩니다.

### 2. 참조 무결성(Referential Integrity)

-   **정의**: 테이블 간에 관계가 설정될 때, 한 테이블의 외래키가 다른 테이블의 기본키를 정확하게 참조해야 합니다. 즉, 외래키 값은 참조하는 테이블의 기본키 값 중 하나거나 NULL이어야 합니다. 예를 들어, 수강신청 테이블에서 학생 테이블의 학번을 참조한다면, 수강신청 테이블의 학번 필드 값은 학생 테이블에 존재하는 학번이거나, 참조가 필요 없다면 NULL이어야 합니다.

### 3. 도메인 무결성(Domain Integrity)

-   **정의**: 테이블의 모든 필드(열)는 선언된 도메인(유효한 값의 집합)에 속한 값만을 가져야 합니다. 이는 데이터 타입, 길이, 가능한 값 등에 대한 제약을 포함합니다. 예를 들어, 성적 테이블에서 성적 필드가 0에서 100 사이의 값만을 허용한다면, 이는 도메인 무결성을 보장하는 조건입니다.

### 4. 사용자 정의 무결성(User-Defined Integrity)

-   **정의**: 애플리케이션의 특정 요구 사항에 맞춰 설정하는 무결성 조건입니다. 예를 들어, 회사의 정책상 직원의 나이가 특정 범위에 속해야 한다거나, 특정 부서에 속한 직원만 특정 작업을 할 수 있는 경우 등이 이에 해당합니다.
